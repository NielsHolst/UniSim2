After you have succesfully run a box script in \US, you will find a \concept{text file} and an \concept{R file} in the \US\ output folder (see \iref{ch:where-is-the-output}). However, you will routinely ignore these files because they are automatically read by the R code put into the \concept{clipboard} at the same time by \US. This chapter describes in detail how output is generated by \US, and how you can adjust and extend the output for your own purposes.

\section{Install R packages}
Remember to install the R packages needed to process \US\ output, as described in \iref{ch:install-r}.

\section{Clipboard output}
Immediately after you have run a box script, \US\ will put a few lines of R code into the clipboard. If you go and paste these lines at the R prompt, you will soon as an effect see the simulation output (as specified by \code{ROutput} in the box script) popping up as R plots. 

The code in the clipboard carries out four tasks in R:
\begin{enumerate}
\item Prepare the R environment (customizable)
\item Define functions to read input and plot output (generated by \US)
\item Set variable with name of output file (customizable)
\item Analyze and show results (customizable)
\end{enumerate}

As an example, after you have run the \filenameexplained{book/egg1.box} script, \US\ will have put several lines into the clipboard. The exact clipboard content will vary but you can always find these four lines:

\lstset{numbers=left}
\begin{rscript}
source("%\inputfolder%/scripts/begin.R")
source("%\outputfolder%/egg1_%\textit{nnnn}%.R")
output_file_name = "%\outputfolder%/egg1_%\textit{nnnn}%.txt"
source("%\inputfolder%/scripts/end.R")
\end{rscript}
\lstset{numbers=none}

Note the use of \inputfolder\ and \outputfolderexplained\ to represent concrete folder paths that will differ between computers.

You can change the customizable parts of the generated clipboard contents through these three input ports of \code{OutputR}:
\begin{itemize}
\item \codenobox{begin}, the name of the script sourced in line 1 (defaults to \code{"scripts/begin.R"})
\item \codenobox{outputFileNameVariable}, the name of the variable in line 3 (defaults to \code{"output_file_name"})
\item \codenobox{end}, the name of the script sourced in line 4 (defaults to \code{"scripts/end.R"})
\end{itemize}

It is common to fine-tune the output by writing one's own \code{end} script in R, while someone yet has to find a good reason change either \code{begin} or \code{outputFileNameVariable}.

The \filename{begin.R} and \filename{end.R} scripts are found in the \filename{\inputfolder/scripts} folder. \US\ comes with default definitions of these two scripts, which you should not change (well, then you are on your own). 

\section{The \code{begin.R} script}

The default \filename{begin.R} script is found in \filename{\inputfolder/scripts}. You can take a look at it. It loads all the necessary libraries and sets up the default formats for the \code{ggplot2} package, which is used for all plotting. It also defines quite many functions to produce different kinds of plots. These functions are used by the generated R script, exemplified by (\filename{egg1_\textit{nnnn}.R}) in line 2 above.

\todo{Note: The remaining sub-sections are under revision. They may be imprecise. }


\section{The generated script}
The script generated by \US\ is given the same name as the script that was loaded and run at the \US\ prompt, except it is given a running number and an \filename{.R} suffix. The file is found in the \US\ \concept{output folder} (see how to set up \US\ folders in \iref{ch:tell-where-files-are}). 

\code{OutputR} is the box responsible for generating the script (in its \code{debrief} step; read about the \US\ computation steps in \iref{ch:computations}). For simplicity, you should only have one \code{OutputR} box in a box script. Here is the one defined in the \filename{\ushome/book/week01/butterfly_with_date.box} script:

\lstset{numbers=left}
\begin{boxscript}
OutputR {
  PageR {
    .xAxis = calendar[date]
    PlotR {
      .ports = (butterfly/*[content])
    }
  }
}\end{boxscript}
\lstset{numbers=none}

For each \code{PageR} box, \code{OutputR} will generate one \concept{page function} in R; and for each \code{PlotR} box, \code{PageR} will generate one call of a \concept{plot function}.

In this example there is only one \code{PageR} box and it holds only one \code{PlotR} box. Hence, one page function with one call of a plot function will be generated. Here is the \filename{butterfly_with_date_\textit{nnnn}.R} script (found in \filename{\ushome/output}) produced by the \filename{butterfly_with_date.box} script:
\lstset{numbers=left}
\begin{rscript}
page_1 <- function(df) {
  grid.arrange(
    plot_facetted(df, "date", c("egg.content", 
      "larva.content", "pupa.content", "adult.content"),
      ncol=1, nrow=NULL),
    nrow = NULL,
    ncol = NULL
  )
}
plot_all <- function(df) {
  page_1(df)
}
\end{rscript}
\lstset{numbers=none}

The page function is called either \code{page_\textit{number}} or \code{page_\textit{name}}. For unnamed \code{PageR} boxes (as in this example), the \code{page_\textit{number}} format is used with consecutive numbers. For named \code{PageR} boxes, the \code{page_\textit{name}} format is used with the \code{\textit{name}} part equal to the name of the \code{PageR} box. Finally, a function \code{plot_all} is generated. It calls each of the page functions one by one thereby displaying all the output.

The page function (lines 1-9 above) uses \code{grid.arrange} (line 6) to put the plots defined in the \code{OutputR} box on the same page. Each \code{PlotR} object inside the \code{OutputR} box results in one function call, either of \code{plot_facetted} (like here, in line 7) or \code{plot_merged}. Which of the two functions are called depends on the \code{format} port of \code{PlotR}, which can be set to either \code{"facetted"} or \code{"merged"}. A facetted plot (the default) results in a plot with one panel for each output variable in the plot, wheres a merged plot results in just one panel will all the output variables cpmbined into one plot. Which variables to plot are determined by the \code{ports} port of PlotR (line 5 in the box script excerpt above).

Both \code{PageR} and \code{PlotR} have \code{nrow} and \code{ncol} input ports.  For \code{PageR}, \code{nrow} and \code{ncol} (lines 6-7) are used as input to the \code{grid.arrange} function. You can read how they work in the \code{grid.arrange} documentation (at the R prompt type \rcom{?grid.arrange}). For \code{PlotR}, \code{nrow} and \code{ncol} (line 5) are used as input to the \code{facet_wrap} function. If the plot is not facetted then \code{nrow} and \code{ncol} are not used. Since, in this example, we did not set the value of any \code{nrow} or \code{ncol} port in the box script, the values you see (lines 5-7) are the default values.

\section{The \code{end.R} script}
It is the purpose of the \code{end.R} script to actually show the results of a model run. By default it reads the text output and then shows the plots:

\lstset{numbers=left}
\begin{rscript}
sim = read_output(output_file_name)
plot_all(sim)
\end{rscript}
\lstset{numbers=none}
First (line 1) the output is read and stored in a \code{sim} data frame, making use of the \code{read_output} function defined in the 
\filename{begin.R} script and the \code{output_file_name} defined in line 3 of the clipboard. Then \code{sim} is used as an input to the \code{plot_all} function defined in the \US-generated script.

\section{Text file output}
The text file output  holds a time trace of all the ports needed to produce the plots in R. These ports include the ones you chose to put on the \(x\) axes on the one or more \code{PageR} boxes, that you included in the box script (by way of the \code{.xAxis} input to \code{PageR}; see line 3 in the box script excerpt further down).

Included in the text file as well are all the outputs, you chose to put on the \(y\) axis by way of the \code{.ports} input to the \code{PlotR} boxes, that you included in the box script (see line 5 in the box script excerpt further down).

If you run the script \filename{\ushome/book/week01/butterfly_with_date.box}, it will produce a file called \filename{butterfly_with_date_\textit{nnnn}.txt} in the \US\ output folder. Here are the first eight lines of that file:
\begin{usoutput}
date egg.content larva.content pupa.content adult.content
ymd NA NA NA NA
2016/5/1 100 0 0 0
2016/5/2 100 0 0 0
2016/5/3 100 0 0 0
2016/5/4 100 0 0 0
2016/5/5 99.9997 0.000253931 0 0
2016/5/6 99.8066 0.193424 0 0
\end{usoutput}
The file contains one column for each port selected for output. The items on each line are separated by tab stops.

The columns reflect the ports needed to produce the plots in R. In the \filename{butterfly_with_date.box} script you will find:
\lstset{numbers=left}
\begin{boxscript}
OutputR {
  PageR {
    .xAxis = calendar[date]
    PlotR {
      .ports = (butterfly/*[content])
    }
  }
}\end{boxscript}
\lstset{numbers=none}

Should a port be mentioned more that once in the output, it will only occur once in the text file. Column labels are constructed by \US\ to be unique and as short as possible. Thus as you develop your model and the box script grows, columns may change name in the output to keep them unique.

The default \code{end.R} script reads the text file into R as an R data frame (\code{sim}), using the \code{read_output} function defined in the \code{begin.R} script. The \code{read_output} function uses the format information in the second line of the text file to interpret the column data correctly. 
 
If you want access to the data in the text file, maybe to do statistics or produce special plots, you simply access the \code{sim} data frame. Here, for example, the first line will show the maximum value of each column, and the second line will produce output plots focusing on steps 20 to 30 of the simulation:
\lstset{numbers=left}
\begin{rscript}
> colwise(max)(sim)
> plot_all(sim[20:30,])
\end{rscript}
\lstset{numbers=none}

\section{Plot window}
If your \code{OutputR} box contains more than \code{PageR} box, it will generate more than one page of outputs; one page for each \code{PageR} box. If you are using R Studio, these pages will be stacked in the R Studio, and can leaf through them. If you are using R GUI (classic R), the pages will be superimposed and you will only be able to see the last one.

On both versions of R, you can ask \US\ to have the output shown in pop-up windows in R. This solves the problem of superimposed output pages in R GUI; each output page will be shown in a seperate pop-up window.

If you show output in pop-ups, this will also allow you to set the size of the ouput pages which can be important for the best presentation of the data.

In the \filename{\ushome/book/week01/butterflies_popup.box} script, the \code{OutputR} box directs the output to two pop-up windows:

\lstset{numbers=left}
\begin{boxscript}
OutputR {
	.popUp = TRUE
	.width = 10
	.height = 4
	PageR {
		.xAxis = sim[step]
		PlotR {
			.ports = (hero/*[content])
		}
	}
	PageR {
		.xAxis = sim[step]
		PlotR {
			.ports = (io/*[content])
		}
	}
}
\end{boxscript}
\lstset{numbers=none}

By setting the \code{popUp} input to \code{TRUE} (line 2), all the \code{PageR} boxes inside this \code{OutputR} box will be shown as pop-ups. The \code{width} and \code{height} inputs set the dimensions of the pop-up windows. The units are interpreted by R; I recommend you just experiment with them for the best results.

The \code{PageR} box has its own \code{width} and \code{height} inputs. By default they refer to the \code{width} and \code{height} inputs of the enclosing \code{OutputR} box. If you run the \filename{\ushome/book/week01/butterflies_popup_2.box} script, you will find that the second pop-up is smaller than the first one. Its output is defined thus:

\lstset{numbers=left}
\begin{boxscript}
OutputR {
	.popUp = TRUE
	.width = 10
	.height = 4
	PageR {
		.xAxis = sim[step]
		PlotR {
			.ports = (hero/*[content])
		}
	}
	PageR {
		.xAxis = sim[step]
		.width = 8
		.height = 3
		PlotR {
			.ports = (io/*[content])
		}
	}
}
\end{boxscript}
\lstset{numbers=none}

Here, in the dimensions of the second page is set explicitly (lines 13-14). Only the first page retains the general dimensions set by \code{OutputR} (lines 3-4).


